# Послідовність того, що робив

## Етап 1 - 06-06-2024

1. Створюємо папку `public`
2. В цій папці буде папка `assets` в ній будуть лежати стилі
3. Далі в папці `public` розташовуємо файли
   1. `index.tpl.php` - цей файл буде слугувати для відображення видів від логіки
   2. `index.php` - в цьому файлі буде сама логіка
   3. Слід звернути увагу, які лінки ми використовуємо. Тобто, якщо нам потрібно зробити перехід з файлу по навігації. то в тегові `<a href="about.php">About</a>` має бути посилання на файл `about.php` - який по суті в нас і являється контролером, а не на файл `about.tpl.php`. Бо це буде викликати таку складність, що змінні з файлу `about.php`, не будуть потрапляти у вид файлу `about.tpl.php`

## Етап 2 - 06-06-2024

1. Створив папки `app`, `core`
   1. В папці `app` поки папка `views` в ній ще папка `components` це мені потрібно, щоб зробити більш кращу структуру проекту Доброго ранку, будуть лежати ті частини які частіше всього повторюються. в моєму випадку, це файл `header.php`, `footer.php`, `sidebar.php` - які я потім буду підключати у їх відповідних видах
   2. В папці `core` в мене поки тільки файл `constatnts.php` - тут константи до мого проекту які будуть полегшувати різного роду підключення папок, та файлів
2. Ініціював файл `composer.json`
   1. Та поки інсталював `larapack/dd` для більш зручної відладки проекту

## Етап 3 - 06-06-2024

1. Створив папку `controllers`, куди перемістив наші перші два контролери `index.php`, `about.php`
2. Ми створюємо фронт конт контроллер. Тут суть в тому, щоб створити файл `.htaccess` яки буде приймати запит і відправляти його у папку `public/index.php`. І в цій же папці `public`, має бути файл `.htaccess`, який цей запит обробить

## Етап 4 - 07-06-2024

1. Ми зробили протенький роутінг у файлі `index.php`, ми додали таку строку `$uri = trim(parse_url($_SERVER['REQUEST_URI'])['path'], '/');`, де:
   1. `trim` - по бокам буде обрізати якщо є `\`
   2. `parse_url` - функція, яка розбиває наш URL на `scheme`, `host`, `path`,`query`. В нашогму випадку, ми будемо вивкорристовувати `path`, що отримувати доступ до певної сторінки
      1. `scheme` - https
      2. `host` - це доменне імя нашого сайту
      3. `path` - це шлях на певну сторінку, який ми і будемо використовувати для роутінгу
      4. `query` - GET параметри, для отримання доступу для певних постів, товарів, пошуку, фільтрів тощо.
   3. `$_SERVER['REQUEST_URI']` - містить URI (Uniform Resource Identifier) поточного запиту. Вона використовується для отримання повного шляху до сторінки, включаючи параметри запиту.
2. Зробили у файлі `func.php` функцію `aboard` яку будемо використовувати, щоб редіректити користувачів на сторінку з помилкою, якщо запитуваної стоірнки не існує
3. Поправили файлик `.htaccess` а саме поле `RewriteRule (.*) index.php?$1 [L,QSA]`, додали `[L,QSA]`, якщо простими словами, то це дозволить нам, не втрачати `GET` параметри, які ми отримуємо з URL строки і потім вже коректно з ними працювати
   1. `[L,QSA]`: Це прапори, які змінюють поведінку правила: 1. `L (Last)`: Вказує, що це останнє правило, яке потрібно виконати. Після нього більше ніякі правила не обробляються. 2. `QSA (Query String Append)`: Вказує, що до кінцевого URL потрібно додати вихідний рядок запиту (query string).
      [Приклад того, як це буде виглядати якщо задампити наш GET запит](https://i.imgur.com/ExgIC6w.png) - тобто ми будемо конкретно бачити, який `ID` прийшов в `GET` запиті

## Етап 5 - 07-06-2024

1. Зробив невелику перестановку файлів
2. Зробив окремий файл в `config/routes.php` - який в нам буде відповідати за карту маршрутів
3. Створив окремий файл `core/router.php` - яка буде оброблювати наші роути. Виніс через ту причину, що наш файл, який є точкою входу `index.php` має бути максимально тонким
4. Підготував базу даних `blog`, з таблицею `posts` [Приклад таблиці](https://i.imgur.com/9VsLXXe.png)

## Етап 6 - 11-06-2024

1. Спочатку інталювали пакет `dotend` [phpdotenv](https://packagist.org/packages/vlucas/phpdotenv). Та створили два файла `.env` and `.env.examples`
2. Створили файл конфігурацій `config/db_config` = тут будемо передавати дані для підключення до бази даних через `PDO`
3. Створили класс `core/classes/Database.php` - де будемо безпосередньо виконувати підключення до бази даних
4. Змінив назву для контролера `index.php` на `home.php`, та змінив віцдповідні його види
5. У файлі `home.php` за допомогою підключення до бази даних, та `SQL` запиту, отримав з бази всі пости та відобразив їх у відповідному виді. Та також запитом `SELECT * FROM `posts`ORDER BY`id`DESC LIMIT`, отримав три останні пости, щоб відобразити їх у `sidebar` з відповідної змінної `$list_group`

## Етап 7 - 14-06-2024

1. У файлі `Database` - створили декілька методів для отриманні даних з таблиці
   1. `findAll` - метод який буде діставати з талиці всі пости
   2. `find` - метод який буде діставати один пост по його ID
   3. `findOrFail` - метод який буде перевіряти, чи є пост в методі `find` за його `ID`. Та якшо такого поста немає, буде запускати функцію `aboard`
2. Також в файлі `Database` - переписали метод `query`, таким чином, щоб він повертав методи цього класу ланцюжком, та зробили запобігання SQL інєкціям

   ```php
      public function query ($query, $params = []) {
         $this->statement = $this->connection->prepare($query);
         $this->statement->execute($params);

         return $this;
      }
   ```

   1. `$query` - Строка, що містить SQL-запит з плейсхолдерами для параметрів (наприклад, ? або :param).
   2. `$params` - Масив параметрів, які будуть підставлені у відповідні місця у запиті. За замовчуванням це порожній масив.
   3. `$this->statement = $this->connection->prepare($query);` - Підготовка SQL-запиту з використанням методу prepare.
   4. `$this->statement->execute($params);` - Виконання підготовленого SQL-запиту з переданими параметрами.
   5. `return $this;` - Повертає поточний об'єкт, що дозволяє викликати методи класу ланцюжком.

   > Приклад використання
   > `$post = $db->query("SELECT * FROM posts WHERE id = ? LIMIT 1", [$id])->findOrFail();`

   1. Викликається метод query, який готує та виконує SQL-запит для вибірки запису з таблиці posts, де `id` дорівнює значенню змінної `$id`. Плейсхолдер ? у запиті замінюється значенням $id з масиву параметрів `$id`.
   2. Після виконання запиту викликається метод `findOrFail` на об'єкті, який повернув метод `query`. Цей метод має бути реалізований в класі `Database` і повинен або повертати знайдений запис, або генерувати помилку, якщо запис не знайдено.

3. Створив контролер `post.php` та його вид `post.tpl.php`

## Етап 8 - 14-06-2024

1. Застосував патерни Singleton [Одинак на PHP](https://refactoring.guru/uk/design-patterns/singleton/php/example)
   Патерн Singleton потрібен для того, щоб гарантувати, що в програмі існує тільки один екземпляр певного класу. Він забезпечує глобальну точку доступу до цього екземпляра.

   ### Основні цілі:

   1. **Єдиний екземпляр**: Забезпечує наявність тільки одного об'єкта класу.
   2. **Глобальний доступ**: Дозволяє будь-де в коді отримати доступ до цього об'єкта.

   ### Використання:

   - **Логування**: Всі частини програми можуть записувати логи в один і той же об'єкт.
   - **Налаштування**: Глобальні конфігурації, доступні з будь-якого місця в програмі.
   - **Робота з базою даних**: Єдиний об'єкт для керування з'єднанням з базою даних.

   ### Приклад:

   ```php
   class Singleton {
      private static $instance = null; // Приватна змінна для зберігання єдиного екземпляра

      private function __construct() {} // Приватний конструктор
      private function __clone() {} // Заборона клонування
      private function __wakeup() {} // Заборона десеріалізації

      public static function getInstance() {
         if (self::$instance === null) {
               self::$instance = new self(); // Створення єдиного екземпляра
         }
         return self::$instance; // Повернення екземпляра
      }
   }

   // Використання Singleton
   $db = (Database::getInstance())->getConnection($db_config);
   ```

## Етап 9 - 15-06-2024

1. Створили контролер `post-create.php`, та його вид `post-create.tpl.php`
2. Контролер `post-create.php`, буде приймати дані з форми, з сторінки `post-create.tpl.php`, обробляти їх, та відправляти в базу
   1. При обробленні даних, які приходять методом `POST` слід враховувати, що при перезавантаженні сторінки, браузер буде просити відправити ці дані ще раз. Щоб цього не було, нампотрібно використовувати `headers`, щоб повторно редіректити на сторінку зі створення поста
3. `$_SERVER['REQUEST_METHOD']` - цей метод дозволяє нам, зрозуміти, яким методом, були відправлені дані з форми, та таким чином, робити їх обробку
   > Приклад:

```php
   if ($_SERVER['REQUEST_METHOD'] == "POST") {
      // виконати код
   }
```

4. `$fillable` - ця змінна дозволить нам, передавати параметри в функцію `vlidateInputsWithForm`
   1. `vlidateInputsWithForm` - Логіка цієї функції полягає в тому, щоб перевірити і відфільтрувати дані, що надійшли через `POST-запит`, залишивши тільки ті поля, які дозволені (згідно з масивом `$fillable`). Це корисно для захисту від надмірних або небажаних даних, які можуть бути надіслані користувачем через форму.
5. `validateOnEmpty` - призначена для перевірки масиву на наявність порожніх значень. Вона приймає масив елементів, перевіряє кожен елемент на порожність та повертає асоціативний масив з помилками для тих елементів, які виявилися порожніми.
6. Додав валідацію полів, які будуть відправлені з форми. [Приклад:](https://i.imgur.com/GlwRdEP.png) - тут використовуємо стандартну валідацію [Bootstrap](https://getbootstrap.com/docs/5.3/forms/validation/)

## Етап 10 - 15-06-2024

1. Зробив так, щоб за умови, якщо якесь з полів заповнено, а якесь ні. То при відправці форми не було такого, що всі введені дані зникнуть. [Приклад](https://i.imgur.com/uP9uJC8.png)
2. Створив функцію `old` - призначена для зручного відновлення значення поля форми після відправки форми. Це корисно, коли форма відправляється, але не проходить валідацію, і потрібно відобразити вже введені користувачем значення у формах знову, щоб він не заповнював їх заново.

```php
   function old($fieldname){
      return isset($_POST[$fieldname]) ? $_POST[$fieldname] : '';
   }
```

[приклад в коді](https://i.imgur.com/gb6HnjM.png)

3. Застосував у функції `validateInputsWithForm` метод `htmlspecialchars` - який дозволить запобігти передачі в базу коде, тобто активних тегів
4. Ще є такий прикол, ми можемо у форму вводити дані таким чином, що ці дані можуть мати **апостроф, дужки, або будь які інши знаки**, а ці знаки, може повпливати на дані в формі, таким чином, що браузер їх просто проігнорує. А проігнорує тому що, ми в тег `input` в його властивість `value` вставимо дані з методу POST, а ці дані наприклад будуть формату `Data " Hello` і тут вийде так, що слово `Hello` буде тупо обрізано, через те що в реченні є подвійні лапки [Приклад](https://i.imgur.com/GO4s3Rx.png). Тому щоб цього запобігти, створив функцію `specialChars` - приймає рядок `$str` як вхідний параметр і обробляє його за допомогою функції `htmlspecialchars`. Ця обробка перетворює спеціальні символи HTML у відповідні HTML-ентітіз, що допомагає запобігти XSS-атакам та іншим проблемам, пов'язаним з небезпечним введенням даних.

```php
function specialChars($str){
    return htmlspecialchars($str, ENT_QUOTES|ENT_SUBSTITUTE);
}
```

[Приклад застосування для запобігання](https://i.imgur.com/PNrh89T.png)

5. Змінив на використанна **іменованих плейсхолдерів** для відправлення запиту в базу [Приклад](https://i.imgur.com/X4fSW7S.png)

   - Тут слід звернути увагу, що ми тепер не повинні передавати дані масивом, а просто передаємо змінну `$data` в яку ми записали масив, після валідації даних функцією `validateInputsWithForm`
   - Вже з цієї змінної будуть взяти **іменовані плейсхолдери**

6. Створив функцію `redirect` - призначена для перенаправлення користувача на вказану URL-адресу. Якщо URL-адреса не вказана, користувач буде перенаправлений на попередню сторінку, з якої він прийшов, або на стандартну адресу, визначену константою `PATH`.

   - Якщо параметр `$url` не порожній, він призначається змінній `$redirect`.
   - Якщо параметр `$url` порожній, функція перевіряє наявність значення в глобальному масиві `$_SERVER` за ключем `HTTP_REFERER`. Цей ключ містить URL сторінки, з якої користувач перейшов на поточну сторінку.
   - Якщо `$_SERVER['HTTP_REFERER']` існує, його значення призначається змінній `$redirect`. Якщо ж ні, використовується константа PATH (яка має бути визначена раніше в коді).

7. Додав окрему перевірку у файл Database.php в його метод query. Перевірка в тому, щоб зробити try catch конструкцію

   - Де `try` буде оброблювати, та виконувати запит в базу
   - А `catch` буде повертати false, у тому випадку, якщо ми зштовнемосб з помилкою

   ```php
         public function query ($query, $params = []) {

         try {
               $this->statement = $this->connection->prepare($query);
               $this->statement->execute($params);
         } catch (PDOException $error) {
               d($error->getMessage());
               return false;
         }

         return $this;
      }
   ```

   - А це все, нам потрібно щоб при виконанні запиту в базу, ми могли на клієнті відобразити статус операції

   ```php
      if (empty($errors)) {

         if ($db->query("INSERT INTO `posts` (`title`, `content`) VALUES(:title, :content)", $data)) {
            echo "OK";
         }else{
            echo "Database error";
         }

      }
   ```

## Етап 11 - 16-06-2024

> Тема досить складна, тмоу буде багато тексту

1. Видалив метод `validateOnEmpty` - через ту причину, що писали свій клас `Validator`
2. Клас `Validator` - призначений для валідації даних за різними правилами. Він перевіряє, чи відповідають введені дані заданим вимогам, і повертає повідомлення про помилки, якщо ці вимоги не виконуються. Клас використовує декілька вбудованих правил валідації та дозволяє легко додавати нові.

Наш валідатор, має наступні властивості:

- `$errors (protected)`: Масив для зберігання повідомлень про помилки валідації.
- `$rules_list (protected)`: Масив з переліком підтримуваних правил валідації. За замовчуванням включає `'required', 'min', 'max', 'email'`.
- `$messages (protected)`: Масив з повідомленнями про помилки для кожного правила. Використовує шаблони з замінниками :fieldname: та :rules:.

Та методи:

- `validate` призначений для перевірки масиву даних за заданими правилами валідації. Він перебирає кожне поле даних і застосовує відповідні правила, викликаючи метод checked для перевірки.

```php
    public function validate($data, $rules): object{
        foreach ($data as $fieldname => $value) {
            if (in_array($fieldname, array_keys($rules))) {
                $this->checked([
                    'fieldname' => $fieldname,
                    'value' => $value,
                    'rules' => $rules[$fieldname],
                ]);
            }
        }

        return $this;
    }
```

- `checked` у класі `Validator` відповідає за перевірку конкретного поля даних відповідно до заданих правил валідації. Він перебирає правила для цього поля і застосовує відповідні методи перевірки. Якщо якесь правило не виконується, додається повідомлення про помилку.

```php
   protected function checked($field){
      foreach ($field['rules'] as $rule => $rule_value) {
         if (in_array($rule, $this->rules_list)) {
               if(!call_user_func_array([$this, $rule], [$field['value'], $rule_value])){
                  $this->addError($field['fieldname'], str_replace([":fieldname:", ":rules:"], [$field['fieldname'], $rule_value], $this->messages[$rule]));
               }
         }
      }
   }
```

- Метод `addError`, яки буде визиватись у функції `checked` щоб зповнювати масив `$errors` дними тих полів, які не пройшли валідацію

```php
    protected function addError($fieldname, $error){
        $this->errors[$fieldname][] = $error;
    }
```

- Два простеньких методи `hasErrors` - буде перевіряти, чи є помилки в масиві `$errors`, та метод `getErrors` - який дозволить отримати дані з масиву `$errors`

- І сворив самі методи, для валідації полів
  1.  `requiredField` - перевирка на обовязковість поля
  2.  `min` - перевірка на мінімальну кількість введених символів
  3.  `max` - перевірка на максимальну кількість введених символів
  4.  `email` - валідація електроної адреси

3. Та приклад того, як ми будемо використовувати клас `Validator`

   Цей код здійснює валідацію даних та, за умови успішного проходження валідації, додає новий запис у базу даних.

   1. **Створення об'єкта `Validator`**:

      ```php
      $validator = new Validator;
      ```

      - Створюється новий екземпляр класу `Validator`.

   2. **Валідація даних**:

      ```php
      $validation = $validator->validate($data, $rules = [
         'title' => [
               'required' => true,
               'min' => 3,
               'max' => 20
         ],
         'content' => [
               'required' => true,
               'min' => 10,
               'max' => 100
         ],
      ]);
      ```

   3. **Перевірка результатів валідації**:

      ```php
      if ($validation->hasErrors()) {
         d($validation->getErrors());
      } else {
      ```

      - Якщо валідація не пройшла, отримуються та виводяться помилки за допомогою методу `getErrors()`.
      - Якщо валідація пройдена успішно, виконуються наступні дії.

   4. **Додавання даних у базу даних**:
      ```php
      if ($db->query("INSERT INTO `posts` (`title`, `content`) VALUES(:title, :content)", $data)) {
         echo "OK";
      }
      ```
      - Виконується SQL-запит на вставку нових даних у таблицю `posts`.
      - Використовуються значення з масиву `$data` для полів `title` та `content`.
      - Якщо запит виконано успішно, виводиться повідомлення "OK".

## Етап 12 - 17-06-2024

1. Спроба створити базовий автозагружчик - автозавантаження класів у `PHP` є дуже корисною і важливою функцією навіть сьогодні. Автозавантаження спрощує керування класами, покращує організацію коду та підвищує продуктивність розробки.

```php
   spl_autoload_register(function ($class) {
    $filename = str_replace("\\", '/', $class) . ".php";
    require_once $filename;
});
```

2. Налаштування простору імен, для підключення класу `Database.php`
3. При налаштуванні простору імен слід враховувати те, що при заповненні даних у файлі `composer.json`, слід запустити команду `composer dump-autoload` - Ця команда, дозволить нам побудувати файл `autoload`, де і будуть будуватись шляхи для автозагрузки і простору імен

> Цікавий факт - при використанні програм, по типу OpenSrver, або XAMPP, MAMP і тд. нам може знадобитись отримати шлях до файлу `php.exe`. Так ось цього, ми можемо досягти, використавши метод `phpinfo()` - то ми побачимо таку змінну як `PHPBIN` де буде шлях до нашого воконуваного файлу

> І тут же, ми можемо взяти шлях до файлу і в консолі вставити шлях в командну строку та додати команду для запуску композеру `C:\OSPanel\modules\PHP-8.1\PHP composer -v` - і виходячи з цього, робимо висновок, що за умови, якщо потрібно використати композер, а наприклад ми неможемо туди отримати доступ з командної строки. Хоча така строка є в OpenSrver наприклад, то для використання іншими програмками підійде

4. Ну і які наші основні кроки, для налашутвання автолоадів для класів
   - налаштування шляхів у файлі composer.json - тобто в цьому файлику, ми вкажемо, за якими папками будемо слідкувати, щоб шукати простір імен наших класів
   - варіант нижче, буде вказувати на папку `app`, та на папку `core`

```json
   "autoload": {
       "psr-4": {
           "App\\": "app/",
           "Core\\": "core/"
       }
   },
   "autho
```

- У файлі з класом, нам потрібно вказати namespaces і шлях до файлу з якого будемо шукати цей клас
- У файлі де потрібно цей клас використати, слід вказати use і шлях до файлу включно з файлом класу який слід підключити

5. Також в налаштуваннях `composer.json`, в блоці `autoload`, можемо підключати файли за потреби, наприклад якщо ми хочемо підключити наш файл констант
   ```php
      "autoload": {
      "psr-4": {
         "Blog\\": "blog/",
         "App\\": "app/",
         "Core\\": "core/"
      },
      "files": [
         "core/func.php"
      ]
    },
   ```
   - тут у масиві `files` - бачимо що підключається функція `func.php` з папки `core` і це говорить нам про те, що підключення у нашій точці входу, тобто у файлику `index.php` більше не потрібно, бо це все, буде робити автозагрузка

## Етап 13 - 18-06-2024

1. Зробив написання функції `errorsList` - мета цієї функції формувати строку з помилками, яку ми будемо виводити у вьюшки

```php
    public function errorsList($fieldname){

        $output = '';
        if(isset($this->errors[$fieldname])){
            $output .= "<div class='invalid-feedback d-block'><ul class='list-unstyled'>";
                foreach ($this->errors[$fieldname] as $error) {
                $output .= "<li>{$error}</li>";
                }
            $output .= "</ul></div>";
        }

        return $output;
    }
```

> [Приклад застосування](https://i.imgur.com/GWUrHMv.png)

2. Трішки змінили логіку в контролері `post-create.php`:
   - за умови якщо немає помилок `!hasErrors()` - будемо виконувати запит в базу
   - Та також додали `$_SESSION['success']` та `$_SESSION['error']`

```php
       if (!$validation->hasErrors()) {
        if ($db->query("INSERT INTO `posts` (`title`, `content`) VALUES(:title, :content)", $data)) {
             $_SESSION['success'] = 'Новий пост було створено';
        }else{
            $_SESSION['error'] = "Database Error";
        }

        redirect();
    }
```

3. Також у файлі `func.php` створив функцію `getAlerts`- мета її дуже проста, вона буде викликатись у файлі `header.tpl.php`, щоб за умови, якщо в наших глобальних змінних - `$_SESSION['success']` та `$_SESSION['error']`, вона буде викидувати алерти

> ПС: поки цей функціонал, налаштовано для файлика `post-create` бо саме у цьому файлі заповнюватимуться дані для глобальної змінно `$_SESSION`

```php
function getAllerts(){
    if(!empty($_SESSION['success'])){
        require_once COMPONENTS . '/success-alert.tpl.php';
        unset($_SESSION['success']);
    }

    if(!empty($_SESSION['error'])){
        require_once COMPONENTS . '/danger-alert.tpl.php';
        unset($_SESSION['error']);
    }
}
```

4. Створив змінну `data_for_validate`у файлі `post-create.php`, ця змінна мені потрібна, щоб імітувати дані, які передаємо до валіадтора. Та просто, зробити додаткові перевірки, для практики

5. Так от, було створено поле `password`, та `repassword`

   - `password` - це наш пароль
   - `repassword` - це полше, має збігатись з полем `password`

6. Щоб перевірити ці два поля, мені потрібно було

   1. Створити функцію `match` в класі `Validatop.php`
   2. Функцію `match`, задекларувати у змінній `$rules_list ` - в цій змінній, в нас знаходяться всі назви методів, які будемо запускати при валідації
   3. Свторив нову властивість класу `protected $data_items;` - її функціональність в тому, щоб у випадку з перевіркою `password`, та `repassword`, ми могли порівнювати ці два значення
   4. Ну і створив логіку самого методу `match`

   ```php
          protected function match($value, $rule_value)
    {
        $match = false;

        if ($this->data_items['password'] === $this->data_items['repassword']) {
            $match = true;
        }

        return $match;

        // це короткий, більш кращий варіант запису, але я вже прям заплутався :)

        // return $value === $this->data_items[$rule_value];
    }
   ```

   5. Але слід звернути увагу, що ми повинні використовувати саме параметри `$value`, та `$rule_value`, а не робити як я, тобто не хардкодити, а брати відповідні нам значення

## Етап 14 - 18-06-2024

1. Створюємо клас `Router` - цей роутер, дозволить нам працювати як з маршрутами по самому сайту, так і робити з API

   - `$routes` - тут ми будемо приймати шляхи з файлу `routes.php`
   - `$uri` - ця властивість має визначати до якої сторінки з URL адреси ми звертаємось
     ```php
     $this->uri = trim(parse_url($_SERVER['REQUEST_URI'])['path'], '/');
     ```
   - `$method` - будемо визначати яким методом відправлено запит на сторінку
     ```php
     $this->method = $_SERVER['REQUEST_METHOD'];
     ```
   - Створюємо метод `match` - мета цього методі перевірити відповідність URL адреси, до карти маршрутів з файлу `routes.php`, та методи яким відправлений в URL, та який в карті маршрутів, щоб запустити виконання також відповідного методу з класу `Router`.

   ```php
      public function match()
      {
         $matches = false;

         foreach ($this->routes as $route) {
               if (($route['uri'] === $this->uri) and ($route['method'] === strtoupper($this->method))) {

                  require_once CONTROLLERS . "/{$route['controller']}";
                  $matches = true;
                  break;
               }
         }

         return $matches;

      }
   ```

   - Викликати цей метод, маємо у файлі `blog/public/index.php`, тобто в точці входу. [Приклад](https://i.imgur.com/HYa5DIx.png)

   - Далі створюємо метод `add` - Метод add додає новий маршрут до списку маршрутів.
     - `$uri (string)`: URI, який визначає маршрут.
     - `$controller (string)`: Контролер, який буде обробляти запит для цього маршруту.
     - `$method (string)`: HTTP метод `(GET, POST, PUT, DELETE)`, який буде використовуватись для цього маршруту.
   - І створюємо методи для обробки методів, якими прийшли дані `(GET, POST, PUT, DELETE)`. [Приклад](https://i.imgur.com/MPYt9ne.png)

2. Далі ідемо будувати карту маршрутів. Це буде файл в `blog/congif/routes.php`

   - А за цим [посиланням](https://laravel.com/docs/11.x/controllers#actions-handled-by-resource-controllers), буде інфо, як правильно будувати шляхи, за які дії вони будуть відповідати, та які контролери викливати, та яким методам належать

   - [Приклад побудови цього файлу](https://i.imgur.com/3gnaRj9.png) - тобто ключовим тут є те, що ми на кожен шлях, робимо запуск свого маршруту і вказуємо на який контролер він має вести

3. Зробили редагування у всіх файлах, щоб вони вели на відповідні шляхи (тут краще глянути коміт)
4. Ще є один ключовий на даному єтапі (це поки ми не побудуємо сервіс провайдери). Тут річ про те, що для використання підключення до бази, слід `$db` використовувати як глобальну змінну
   - спочатку у файлі `blog/public/index.php` ми вказуємо що ця змінна буде [глобальною](https://i.imgur.com/PZgX5MS.png)
   - ну і будемо теж з допомогою ключового слова `global` викликати в кожному з контролерів, де це потрібно

## Етап 15 - 28-06-2024

1. Задачею є те, щоб створити запит на видлаення поста. Але проблемою є те, що ми можемо відправити форму методами `GET` or `POST`
2. Тому будемо робити емуляцію методу `DELETE`

   1. Перше що ми зробимо, це форму у файлі `blog\app\views\posts\show.tpl.php`

   ```php
   <form action="/posts" method="post">
      <input type="hidden" name="id" value="<?= $post['id'] ?>">
      <input type="hidden" name="_method" value="delete">
      <button type="submit" class="btn btn-danger">Delete</button>
   </form>
   ```

   - `<input type="hidden" name="id" value="<?= $post['id'] ?>">` - приховане поле, яке буде просто передавати ID поста, щоб розуміти який пост видаляти
   - `<input type="hidden" name="_method" value="delete">` - ось тут вся фішечка, що нам потрібно зімітувати метод яким було відправлено дані

   2. А застосовувати ці дані ми будемо у файлі `blog\core\classes\Router.php`, а саме у властивості `this->method` ми маємо брати дані з глобального масиву `POST`яким і прийдуть дані з нашої форми
      - [Приклад як це зроблено](https://i.imgur.com/wo0wg3d.png)
   3. І далі, коли потрапимо в клас `Router` в першу чергу, ми перевіримо, чи є дані в глобальному масиві `$_POST['_method']` і якщо вони там є то відпрацюють в першу чергу і направить нас, на відповідний контролер, у нашому випадку на `posts/destroy.php`

3. Як тільки нас перекине на контролер `posts/destroy.php`, ми можемо вже у файлі зробити опис запиту в базу, на видалення. [Приклад](https://i.imgur.com/99LndyO.png)
